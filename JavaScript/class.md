# クラス
正確にはJavaScriptにおいてクラス、インスタンスという区別は存在しない。

JavaScriptにあるのはオブジェクトだけ。

あるオブジェクトをプロトタイプ(雛形)として別のオブジェクトを定義するのが基本。

このようなオブジェクト指向を`プロトタイプベースのオブジェクト指向`と呼ぶ。

JavaScriptにおいてクラスとは雛形=プロトタイプのオブジェクトのこと。

そこからオブジェクト(インスタンス的なやつ)を生成する。

ES2015からclass構文が導入されているが、プロトタイプをそれっぽく見せるためのシンタックスシュガーに過ぎない。

→JavaScriptの本質はあくまでオブジェクトであることを忘れない

---

- クラスの定義

クラスはclass命令で宣言する。
```JavaScript
class Member { }
```
クラスとはメソッドやプロパティなどの要素を収めるための単なる器にすぎない。

クラスをインスタンス化するには組み込みオブジェクトと同じく、`new演算子`を呼び出すだけでok
```JavaScript
class Member { } // 空のクラスを宣言
let m = new Member(); // インスタンス化
console.log(m); // => Member {}
```

`classの特徴`

クラス定義は巻き上げされない→呼び出しよりも先に定義しておく必要あり

classブロック配下はStrictモードで動作する

class {…} の形式でクラスリテラル(クラス式)を表すことも可能→`let Member = class { };` みたいに表現もできる

---

- クラスにプロパティを付与する

プロパティとはインスタンス(オブジェクト)に属する情報(変数)のこと。インスタンス変数と呼ばれることもある。
```JavaScript
class Member {
  name = 'じょん';
  age = 0;
}

let m = new Member();

console.log(m);
// => Member {name: 'じょん', age: 0}

console.log(`私の名前は${m.name}、年齢は${m.age}です`);
// => 私の名前はじょん、年齢は0です
```
プロパティの宣言は、大雑把にはclassブロック配下での変数宣言(letキーワードは不要)

初期値を省略した場合はundefinedとなる。

一旦作成したインスタンスに対して、後からプロパティを追加することもできる。
```JavaScript
let m1 = new Member();
let m2 = new Member();

m1.gender = 'male'; // プロパティの追加

console.log(m1); // Member {name: 'じょん', age: 0, gender: 'male'}
console.log(m2); // Member {name: 'じょん', age: 0}
```
m1の方だけgenderプロパティを追加することができた。

この場合、追加したプロパティはあくまでそのインスタンスだけのもの。

`同じクラスから生成されたインスタンスが同じ変数を持つとは限らない`

---

- クラスにメソッドを付与する

メソッドとはクラスの中で定義された関数のこと。

クラスに関わる共通的な処理はメソッドとしてクラスにまとめるべき。
```JavaScript
class Member {
  name = 'じょん';
  age = 0;
  show() {
    console.log(`私の名前は${this.name}、年齢は${this.age}です。`);
  }
}

let m = new Member();
m.show(); // => 私の名前はじょん、年齢は0です。
```
メソッド定義の構文ではfunctionキーワードが不要。

→オブジェクトリテラルのメソッド簡易構文に準ずるイメージ

`thisキーワード`はnew演算子によって生成されるインスタンス(自分自身)を表すもの。

以下のように使用できる。

`this.プロパティ名`：自身に定義されたプロパティの呼び出し

`this.プロパティ名 = 値`：自身に定義されたプロパティの変更(更新)

`this.メソッド名(…)`：自身に定義された関数の呼び出し

自身に定義された = 現在の自身のクラスのこと

---

- クラスの初期化(コンストラクター)

クラスを利用する際、new演算子によってインスタンスを生成する必要があるが、このインスタンス化のタイミングで実行される特別なメソッドが`コンストラクター`
```JavaScript
class Member {
  constructor(name = 'じょん', age = 0) {
    this.name = name;
    this.age = age;
  }

  show() {
    console.log(`私の名前は${this.name}、年齢は${this.age}です。`);
  }
}

let m1 = new Member();
let m2 = new Member('スーパーじょん', 100);

m1.show(); // 私の名前はじょん、年齢は0です。
m2.show(); // 私の名前はスーパーじょん、年齢は100です。
```
コンストラクター配下のthisは、生成されるインスタンスのこと。

コンストラクターでの初期化コードを簡略化した場合
```JavaScript
class Member {
  constructor(name = 'じょん', age = 0) {
    Object.assign(this, { name, age });
  }
}
```
thisは現在のインスタンス。よって、`現在のインスタンスに対して、引数の内容をまとめてマージする` という意味。

`{ name, age }` の箇所はオブジェクトリテラルの省略構文で`{ name: name, age: age }` と同じ

以前(class構文以前)はクラスはfunction命令で定義をしていた。
```JavaScript
let Member = function(name, age) {
  this.name = name;
  this.age = age;
};
```
クラスという枠組みはなく、コンストラクターを意味する関数(コンストラクター関数)がそのままクラスの役割を担っていた。

`コンストラクター関数のシンタックスシュガーがclass命令` ...のでクラスは内部的には関数

---

- 静的メンバーを定義する

静的メンバーとは静的プロパティ、静的メソッドのこと。

静的プロパティ、メソッドはインスタンスを生成しなくてもオブジェクトから直接呼び出せるプロパティ、メソッドのこと。

定義する時は`staticキーワード`を付与する
```JavaScript
class Area {
  // 静的プロパティ
  static pi = 3.14;

  // 静的メソッド
  static circle(radius) {
    return (radius ** 2) * this.pi;
  }
}

console.log(Area.pi);         // 3.14
console.log(Area.circle(10)); // 314
```
`クラス名.メンバー` の形式で静的メンバーにアクセスできている

`静的メソッド配下のthisは現在のクラスを参照`

→インスタンスメソッドのthisと異なる

→this.pi はインスタンスプロパティでなく、静的プロパティのpiを示している

→静的メソッドからインスタンスのメンバーにアクセスすることはできない
