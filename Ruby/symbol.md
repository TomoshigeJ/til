# シンボル

文字列との違いを意識する。

`alias`や`undef`といった特定の操作において、指定するものが文字列かシンボルかを答えられることが重要。

---

- シンボルリテラル

文字列の先頭にコロン `:` を付与する。

文字列での囲い文字(シングルクォートやダブルクォート)は省略するのが一般的。

→クォートは使用してもいいし、式展開時はダブルクォートを使用する

```ruby
dog1 = :dog1   # => :dog1
dog2 = :'dog2' # => :dog2
dog3 = :"dog3" # => :dog3
dog4 = :"#{dog1}dog4" # => :dog1dog4
```

---

- パーセント記法を用いたシンボルの指定

%s と %i の違いはこんな感じ

```ruby
%s?dog? # => :dog
%s[dog1 dog2] # => :"dog1 dog2"
%i[dog1 dog2] # => [:dog1, :dog2]
```

---

- 文字列とシンボルの変換

Symbolクラスのインスタンスは使用できるメソッドが少ないので、動的にメソッドを作成する場合は、メソッドが豊富な文字列で生成してからシンボルに変換する方法がある。

```ruby
dog = 'dog' # 文字列を生成
dog2 = dog.to_sym # 文字列からシンボルへ変換
dog4 = dog2.to_s # 文字列へ変換
```

---

- オブジェクトの同値性と同一性

`object_idメソッド`を使用することでオブジェクトが同一かどうか判断できる。

文字列リテラルでは毎回新たにオブジェクトを生成するが、シンボルは同一名の場合は同じオブジェクトを参照するのでobject_idは変わらない。

```ruby
p 's'.object_id # => 70278059375780
p 's'.object_id # => 70278046595380 (実行する度に結果は変わる)

p :sym.object_id # => 807388
p :sym.object_id # => 807388 (シンボルはobject_idは変わらない)
```

シンボル内部では整数として扱われるので、文字列に比べ処理が早くなる。

単にラベルとしての文字の列を扱いたい場合はシンボルの方が効率がよい。

2つのオブジェクトが同一かどうか(等しいかどうかではない)は`equal?メソッド`を使用すると論理値で結果を返してくれる。(サブクラスではオーバーライドしない)

```ruby
'dog' == 'dog'      # => true
'dog'.equal?('dog') # => false

:dog == :dog      # => true
:dog.equal?(:dog) # => true
```
