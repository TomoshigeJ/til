# 変数と値

- 変数の代入

```ruby
v1 = 'dog1'
v2 = v1
v1.equal? v2 # => true
```

変数を宣言すると変数にオブジェクトへの参照が与えられる。

変数を他の変数に代入すると両者は同じオブジェクトを指す。

同じオブジェクトを参照すると、ある変数への操作が他にも影響しそうではあるが、大部分は再代入になる。

```ruby
v1 = 'dog1'
v2 = v1
v1 += 'dog2'
p v1 # => "dog1dog2"
p v2 # => "dog1
```

v1には新たに作成した値が格納されるだけで、v2には影響を与えない。

メソッドの引数でも同様に実引数に指定された変数の参照が仮引数にコピーされる。

```ruby
def func v1
  v1.object_id
end

v1 = 'dog1'
p v1.object_id # => 70076032469040
p func(v1)     # => 70076032469040
```

メソッド内部で自己代入

```ruby
def func v1
  v1 += 'dog2'
end

v1 = 'dog1'

p func v1 # => "dog1dog2"
p v1      # => "dog1"
```

---

- 破壊的メソッド

自分自身の内容を変更するメソッドは他の変数の参照先にも影響を与えるので注意。

このようなメソッドを`破壊的メソッド`といい、メソッド名に!をつけるのが習慣的。

```ruby
v1 = 'dog1'
v2 = v1
p v1.chop # => "dog"
p v2      # => "dog1"

### 破壊的メソッド
p v1.chop! # => "dog"
p v2       # => "dog"
```

→chopメソッドは最後の文字を取り除いた文字列を返すメソッド

---

- 文字列とシンボルの違い

```ruby
# 文字列の場合
v1 = 'dog'
v2 = 'dog'
v3 = 'dog'
# v1~v3は別のオブジェクト
p v1.object_id # => 70128473613420
p v2.object_id # => 70128473613400
p v3.object_id # => 70128473613340

# シンボルの場合
v1 = :dog
v2 = :dog
v3 = :dog
# v1~v3は同じオブジェクト
p v1.object_id # => 1026588
p v2.object_id # => 1026588
p v3.object_id # => 1026588
```

変数に文字列を代入していくと、同じ値であってもそれぞれ異なるオブジェクトを指す。

一方でシンボルでは変数が同じオブジェクトを指している。

メソッド名と同様に一意となる特徴から、`aliasやundef`では文字列ではなくシンボルでメソッド名を指定する。
